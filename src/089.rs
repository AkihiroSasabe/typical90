use proconio::input;
use itertools::Itertools;
use std::cmp::{max, min};
use std::cmp::Ordering;
use std::collections::VecDeque;
use std::collections::BinaryHeap;
use proconio::marker::Chars;
fn main() {
    input! {
        n: usize,
        k: usize,
        a: [usize; n]
    }
    let modulus = 1_000_000_007;

    // 解説AC (解説図を読んで、自分で実装)

    // [1]aの圧縮
    //      数列a内の大小関係を維持しながら、
    //      max(a[i]) <= 10^9 を 
    //      max(a[i]) < a.len() = N <= 2*10^5 に圧縮する
    let mut a_sorted = vec![];
    for i in 0..n {
        a_sorted.push((a[i], i));
    }
    a_sorted.sort();
    let mut a_compressed = vec![n; n]; // 圧縮された数列A
    a_compressed[a_sorted[0].1] = 0;
    for i in 1..n {
        if a_sorted[i].0 == a_sorted[i-1].0 {
            a_compressed[a_sorted[i].1] = a_compressed[a_sorted[i-1].1];
        }
        else {
            a_compressed[a_sorted[i].1] = i;
        }
    }

    // [2]バブルソートの回数は、区間内の転倒数に等しい。
    // 閉区間[l,r]のバブルソートの回数制約は、閉区間[l,r]の転倒数の制約に置換可能。

    // [3]転倒数の制約を考慮した制約 min_l[R] を求める
    // min_l[R] := 閉区間[L, R]で転倒数がK以下となる最小のL (E8氏の解説のCLと同じ)
    //     を R=0, 1, ..., N-1 について求める
    //     ↑min_lは後でDPの遷移計算の為に使う。今はとりあえず脳死でこれを求める方法を考える。
    let mut min_l: Vec<usize> = vec![n; n]; // nで初期化 (min_lは[0,n-1]しかありえない)

    // min_l は愚直にやると、LとRの走査でO(N^2)、閉区間[L,R]での転倒数の計算でO(N)なので、合わせてO(N^3)かかる

    // [4] min_l を 尺取り法 で計算量削減して取得: O(N^3) -> O(N^2)
    // 尺取り法だとLとRの走査でO(N), 閉区間[L,R]の転倒数の計算にO(N)なので、合わせてO(N^2)
    // しかしN <= 2*10^5 なのでO(N^2)だとTLE(>3sec)する。

    // [5] min_l を尺取り法 + BIT で計算量削減して取得: O(N^2) -> O(NlogN)
    // min_l を BIT で計算すると、閉区間[L,R]の転倒数の計算がO(logN)になるので、全体で min_l がO(NlogN)で計算できる
    // bit[i]には、数列Aの区間[l,r]にいる値iの個数を格納. 
    // bitのサイズは、max(a[i])+2に等しい。
    // max(a[i])は、10^9 -> 2*10^5まで圧縮されたので、メモリ不足になることはない
    let mut bit: BinaryIndexedTree<isize> = BinaryIndexedTree::new(n);

    // 初期状態
    let mut l: usize = 0;
    let mut r: usize = 0;
    // 区間[l,r]の転倒数
    let mut inversion_number: isize = 0; // 初期状態では、[l,r]=[0,0]でAの項数1個なので転倒数0
    bit.add(a_compressed[l], 1);
    loop {
        if inversion_number <= k as isize {
            // 区間[l,r]の転倒数がk個以下
            min_l[r] = min(min_l[r], l);

            // rを右に1個進める
            r += 1;
            if r >= n {break} // r = n になったら終了

            // a_compressed[r]を区間に追加したら転倒数はどうなるか?
            // 数列[l, r-1]に居るa_compressed[r]より大きい項の数だけ転倒数は増える。
            inversion_number += bit.sum(n-1) - bit.sum(a_compressed[r]);
            // bitにもrを追加
            bit.add(a_compressed[r], 1); // 現在のBITには、数列Aの区間[l,r]の項が格納されている
        }
        else {
            // 区間[l,r]の転倒数がk個より大きい

            // bitから第l項を削除
            bit.add(a_compressed[l], -1); // BITには数列Aの区間[l+1, r]の項が格納されている

            // a_compressed[l]を区間から削除したら転倒数はどうなるか?
            // 数列[l+1, r]に居るa_compressed[l]より小さい項の数だけ転倒数は増える。
            if a_compressed[l] != 0 {
                // a[l]==0のときは、区間[l+1,r]の値よりもa[l]の値が絶対小さくなって転倒数が変わらないのでスキップ
                inversion_number -= bit.sum(a_compressed[l]-1);
            }

            // lを左に1個進める
            l += 1;
        }
    }
    // println!("min_l = {:?}", min_l); // 入力例2のとき、min_l = [0, 0, 0, 1, 3, 3, 3]
    
    // [6] 動的計画法で分割方法の総数を求める
    // dp[r] := 閉区間[0,r]までの分割する方法の総数
    let mut dp = vec![0; n];
    dp[0] = 1;

    // cum_dp[r] := 閉区間[0,r]までのdp[i]の累積和
    let mut cum_dp = vec![0; n];
    cum_dp[0] = dp[0];

    // 動的計画法の遷移. 計算量は累積和を使うとO(N)で計算可能. 
    // 遷移の例は、main()関数の下側にコメント記載した
    for r in 1..n {
        let min_left = min_l[r]; // 転倒数がK以下となる閉区間[L, R]で、Rを固定したとき最小のL
        match min_left {
            0 => dp[r] = cum_dp[r-1] + 1,   // Σ[l=1,r](分割可能区間[0,l-1] x 連続区間[l,r]) + 連続区間[0, r]. 連続区間は全部1通り.
            1 => dp[r] = cum_dp[r-1],       // Σ[l=1,r](分割可能区間[0,l-1] x 連続区間[l,r])
            _ => dp[r] = modulus + cum_dp[r-1] - cum_dp[min_left - 2] // Σ[l=min_left,r](分割可能区間[0,l-1] x 連続区間[l,r])
        }
        dp[r] %= modulus;
        
        cum_dp[r] = cum_dp[r-1] + dp[r];
        cum_dp[r] %= modulus;
    }

    println!("{}", dp[n-1]);


    // ■動的計画法における各状態を実際に列挙
    // 入力例1
    // index   : 0 1 2 3
    // a[i]    : 2 0 3 1
    // min_l[r]: 0 1 1 3
    // dp[i]   : 1 1 2 2
    // dp[i] := a[0:i+1]で、バブルソートの交換回数 が K 以下である区間の組み合わせ総数

    // dp[0]:{2}
    // dp[1]:{2}{0}
    // dp[2]:{2}{0}{3} 前回と繋げない
    //      :{2}{0, 3} 前回と繋げる
    // dp[3]:{2}{0}{3}{1} 前回と繋げない
    //      :{2}{0, 3}{1} 前回と繋げない


    // 入力例2:
    // index   : 0 1 2 3 4 5 6
    // a[i]    : 5 3 6 1 0 1 3
    // min_l[r]: 0 0 0 1 3 3 3
    // dp[i]   : 1 2 4 7 

    // dp[0]のケースを網羅
    // 2^0 = 1個 (仕切りはどこにも置けない)
    // index:  0
    // case : {5}
    // 上の結果よりmin_l[0] = 0
    
    // dp[1]のケースを網羅
    // 2^1 = 1個 (i=0,1の間に仕切りを置くか否か)
    // index:  0    1
    // case : {5}, {3} 前回と繋げない
    // case : {5,   3} 前回と繋げる
    // 上の結果よりmin_l[1] = 0

    // dp[2]のケースを網羅
    // 2^2 = 4個 (i=0,1の間とi=1,2の間に仕切りを置くか)
    // index:  0    1    2
    // case : {5}, {3}, {6} 前回と繋げない
    // case : {5,   3}, {6} 前回と繋げない
    // case : {5}, {3,   6} 前回と繋げる
    // case : {5,   3,   6} 前回と繋げる
    // 上の結果よりmin_l[2] = 0

    // dp[3]のケースを網羅
    // 2^3 = 8個. 1個おけないので 8 - 1 = 7通り
    // index:  0    1    2    3
    // case : {5}, {3}, {6}, {1} 前回と繋げない 
    // case : {5,   3}, {6}, {1} 前回と繋げない
    // case : {5}, {3,   6}, {1} 前回と繋げない   
    // case : {5,   3,   6}, {1} 前回と繋げない     
    // case : {5}, {3}, {6,   1} 前回と繋げる 
    // case : {5,   3}, {6,   1} 前回と繋げる
    // case : {5}, {3,   6,   1} 前回と繋げる   
    // case : {5,   3,   6,   1} 前回と繋げる <- 転倒数4 > K=2なのでNG.
    // 上の結果よりmin_l[3] = 1

    // dp[4]のケースを網羅
    // 2^4 = 16個. 前回7個なので、7 * 2 - 3 = 9通り
    // index:  0    1    2    3    4
    // case : {5}, {3}, {6}, {1}, {0} 前回と繋げない 
    // case : {5,   3}, {6}, {1}, {0} 前回と繋げない
    // case : {5}, {3,   6}, {1}, {0} 前回と繋げない   
    // case : {5,   3,   6}, {1}, {0} 前回と繋げない     
    // case : {5}, {3}, {6,   1}, {0} 前回と繋げない 
    // case : {5,   3}, {6,   1}, {0} 前回と繋げない
    // case : {5}, {3,   6,   1}, {0} 前回と繋げない   
    // case : {5}, {3}, {6}, {1,   0} 前回と繋げる 
    // case : {5,   3}, {6}, {1,   0} 前回と繋げる
    // case : {5}, {3,   6}, {1,   0} 前回と繋げる   
    // case : {5,   3,   6}, {1,   0} 前回と繋げる   
    // case : {5}, {3}, {6,   1,   0} 前回と繋げる <- 転倒数3 > K=2なのでNG
    // case : {5,   3}, {6,   1,   0} 前回と繋げる <- 転倒数3 > K=2なのでNG
    // case : {5}, {3,   6,   1,   0} 前回と繋げる <- 転倒数5 > K=2なのでNG
    // 上の結果よりmin_l[4] = 3


    // ■動的計画法の遷移
    // 連続区間[l,r]の個数dp[l][r]を知りたい.最終的にはdp[0][n-1]が知れれば良き
    // 入力例2のときの例
    // r=0, min_l[r] = min_l[0] = 0
    // dp[0][0] = 1; // 連続区間[0,0]の個数
    // dp[0]    = 1; // dpを2次元の配列として用意したが、実際に使うのはdp[0][r]だけなので、1次元の配列dp[r]で十分

    // r=1, min_l[r] = min_l[1] = 0
    // dp[0][1] = dp[0][0] + 1; // 分割可能区間[0,0]と連続区間[1,1] + 連続区間[0,1]の個数
    // dp[1]    = dp[0]    + 1; // dpを2次元の配列として用意したが、実際に使うのはdp[0][r]だけなので、1次元の配列dp[r]で十分
    //          = cum_dp[0]+ 1;

    // r=2, min_l[r] = min_l[2] = 0
    // dp[0][2] = dp[0][1] + dp[0][0] + 1; // 分割可能区間[0,1]と連続区間[2,2] + 分割可能区間[0,0]と連続区間[1,2] + 連続区間[0,2]の個数
    // dp[2]    = dp[1]    + dp[0]    + 1; // dpを2次元の配列として用意したが、実際に使うのはdp[0][r]だけなので、1次元の配列dp[r]で十分
    //          = cum_dp[1]           + 1;

    // r=3, min_l[r] = min_l[3] = 1
    // (第1項)1個前と繋げない + (第2項)1個前まで繋げて、2個前と繋げない + (第3項)2個前まで繋げて、3個前と繋げない。
    // min_l[3]=1より、r-min_l[r]=3-1=2となり2個前まで繋げられるが、3個より前以上は繋げられないのでここまで足せば十分
    // dp[0][3] = dp[0][2] + dp[0][1] + dp[0][0] (+ 1 は足さない); // 分割可能区間[0,2]と連続区間[3,3] + 分割可能区間[0,1]と連続区間[2,3] + 分割可能区間[0,0]と連続区間[1,3] (+ 連続区間[0,3])
    //          = dp[0][2] + dp[0][1] + dp[0][0]    // min_l[3]=1なので、最後の項は削除
    // dp[3]    = dp[2]    + dp[1]    + dp[0]       // dpを2次元の配列として用意したが、実際に使うのはdp[0][r]だけなので、1次元の配列dp[r]で十分
    //          = cum_dp[2]                         

    // r=4, min_l[r] = min_l[4] = 3
    // dp[0][4] = dp[0][3] + dp[0][2] (+ dp[0][1] + dp[0][0] + 1 は足さない); // 分割可能区間[0,3]と[4,4] + 分割可能区間[0,2]と連続区間[3,4] (+ 分割可能区間[0,1]と連続区間[2,4] + 分割可能区間[0,0]と連続区間[1,4] + 連続区間[0,4])
    //          = dp[0][3] + dp[0][2]               // min_l[4]=3なので、後ろ3つの項は削除
    // dp[4]    = dp[3]    + dp[2]                  // dpを2次元の配列として用意したが、実際に使うのはdp[0][r]だけなので、1次元の配列dp[r]で十分
    //          = cum_dp[3] - cum_dp[1]



    // ■E8氏の解説を見る前に自分がした考察:
    // 数列を1つ以上の空でない連続した区間に分割する方法は 2 ^ (N - 1)通り
    // 仕切りを入れる / 入れない の2択をi=1,2,...N-1について行うので2^(N-1)通り
    // {3, _1, _4, _2} _ が仕切り位置
    // {3, |1, |4, |2} 全部に仕切り挿入
    // {3,  1, |4, |2} i=1以外に仕切り挿入

    // バブルソートO(N^2)の交換回数例
    // 2,4,3,1 :0回
    // 2,3,4,1 :1回 i=1,j=2
    // 2,3,1,4 :2回 i=2,j=3
    // 2,1,3,4 :3回 i=1,j=2
    // 1,2,3,4 :4回 i=0,j=1


    // バブルソートの交換回数は正確にわかるのか?
    // (n-1)*(n-1)がk以下であればもう計算しなくてもわかる
    // 2 4 3 1
    // 1 2 4 3 -> 3回
    // 実際にバブルソートするのもあり。

    // dp[]
    // 3, 1, 4, 2
    // {3, _1, _4, _2}

    // {3, 1, 4}, {2}
    // {3, 1}, {4, 2}
    // {3, 1}, {4}, {2}

    // "仕切り位置の探索"と、"バブルソートの交換回数がK回以下の判定"
    // 仕切り位置をビット全探索だと計算量が 2^N かかる。小課題2(N<15)くらいは解けそう

    // K回未満判定はO(NlogN)できそう
    // {103, 1, 104, 999, 102}とかは
    // {3, 1, 4, 5, 2}にNlogNで置換できるので、
    // 事前にこれのバブルソート回数の結果をメモしておけばO(1)で判定できそう
    // N <= 10^4 

    // 3, 1, 4
    // 3 _ 1 _ 4
    // 3 _ 1 | 4
    // 3 | 1 _ 4
    // 3 | 1 | 4
    
    // 大は小を兼ねる
    // 広い分には問題ない
    // dp[l][r]で管理?　nC2 = n*(n-1)/2 >= O(10^10) 駄目っぽい
}



// Binary Indexed Tree (BIT)
// 参考: https://algo-logic.info/binary-indexed-tree/
// 構築: O(N)
// 加算: O(logN): 数列Anのi番目の項にxを足す (区間加算じゃないので注意)
// 区間和: O(logN): 数列Anの先頭からi番目までの項の和を求める
// セグメント木より機能が限定的だが、実装が簡単 & 定数倍で高速 & 省メモリ
#[derive(Debug, Clone, PartialEq, Eq)]
struct BinaryIndexedTree<T> {
    n: isize,       // 配列の要素数(数列の要素数+1)
    bit: Vec<T>    // データの格納先(1-indexed)。初期値は0
    // 0 始まり(0-indexed) ではなく 1 から番号を始めている(1-indexed)
    // また半開区間ではなく閉区間で考える。
    // これは後で計算をする際に楽になるため。
}

impl<T: Default + Copy + std::ops::AddAssign + std::fmt::Debug> BinaryIndexedTree<T> {
    fn new(n: usize) -> Self {
        BinaryIndexedTree {
            n: (n + 1) as isize,
            bit: vec![T::default(); n + 1] // 例えばTがusizeならdefault()は0を返す
        }
    }

    // add のインターフェースとしてindexは元の数列のindexを採用している(内部で+1している)
    fn add(&mut self, index: usize, x: T) {
        let mut i = (index + 1) as isize;
        // let mut i = index as isize; // こっちを採用すると、インターフェースも半開区間にできる
        while i < self.n {
            self.bit[i as usize] += x;
            // println!("i={}, i={:05b} -i={:05b}", i, i, -i);

            // i の最後の1のビット = i & -i (∵負の数は「ビット反転+1」で表現される)
            // 例: 6 & -6 = (00…0110)_2 & (11…1010)_2 = (00…0010)_2
            i += (i & - i); // iにi の最後の1のビットを足すと、親のインデックスに移れる

            // Rustでは、負の数は2の補数表現で保持される。
            // 補数の定義: N進法において自然数xを表現するのに必要な最小の桁数をnとしたとき
            // xのNの補数はN^n - x となる
            // 例： 5(10進数)=101(2進数)の2の補数は、2^3-5(10進法) = 1000 - 101 (2進法) = 011(2進法)となる
            // 参考1: http://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/negative.html
            // 参考2: http://www.f.waseda.jp/takezawa/math/joho/hosuu.pdf
            // もっと端的に言うと、
            // 0の定義を、そのデータ型のビット数の限界に1桁左から1を追加したものとする
            // 例: 3bitだけ使える場合、下記のように考える
            // -3: 0101
            // -2: 0110
            // -1: 0111
            //  0: 1000 <- 3bitの0の定義
            //  1: 0001
            //  2: 0010
            //  3: 0011
            // また、isizeの場合、-1は
            // 1111111111
            // 1111111111
            // 1111111111
            // 1111111111
            // 1111111111
            // 1111111111
            // 1111 となる (1が64個)。
        }
    }

    // a_1 + a_2 + ... + a_i を計算する (sumのインターフェースは半開区間ではなく閉区間を採用。a[index]は足される)
    fn sum(&self, index: usize) -> T {
        let mut i = (index + 1) as isize;
        // let mut i = index as isize; // こっちを採用すると、インターフェースも開区間にできる
        let mut sum = T::default(); // 例えばTがusizeならdefault()は0を返す
        while i > 0 {
            // println!("i={}, sum={:?}", i, sum);
            sum += self.bit[i as usize];
            // i の最後の1のビット = i & -i (∵負の数は「ビット反転+1」で表現される)
            // 例: 6 & -6 = (00…0110)_2 & (11…1010)_2 = (00…0010)_2
            i -= (i & - i); // iにi の最後の1のビットを引くと、1個左上のノードのインデックスに移れる
            // println!("i={}, sum={:?}", i, sum);
            // println!("==== ==== ==== ====");
        }
        return sum
    }
}

